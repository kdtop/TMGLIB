TMGRX008 ;TMG/kst/Patient medication listing code; 8/6/25
       ;;1.0;TMG-LIB;**1**;08/06/25
 ;
 ;"Code for dealing with saving patients medication list
 ;"~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--
 ;"Copyright (c) 8/6/25  Kevin S. Toppenberg MD
 ;"
 ;"This file is part of the TMG LIBRARY, and may only be used in accordence
 ;" to license terms outlined in separate file TMGLICNS.m, which should 
 ;" always be distributed with this file.
 ;"~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--
 ;
 ;"=======================================================================
 ;" API -- Public Functions.
 ;"=======================================================================
 ;" 
 ;"=======================================================================
 ;"PRIVATE API FUNCTIONS
 ;"=======================================================================
 ;
 ;"=======================================================================
 ;"DEPENDENCIES
 ;"=======================================================================
 ;"Uses:  
 ;"=======================================================================
 ; 
CONSOLE  ;"
  NEW MASTERREF,DONEREF,DELREF,CURREF
  DO GETREFS^TMGRX002(.MASTERREF,.DONEREF,.DELREF,.CURREF) 
  NEW MENU,IDX,OPTION
  NEW ARRAY,OPTION,TEMPCLR
  KILL ARRAY,OPTION
  ;
  SET OPTION("COLUMNS",1,"WIDTH")=30
  SET OPTION("LR SCROLLING")=1
  ;"SET OPTION("SHOW INDEX")=1  
  SET OPTION("LINE NUMBERS")=1
  SET OPTION("ENDSTOP SCROLLING")=0 ;"no end stop
  SET OPTION("MULTISEL")=1
  SET OPTION("MULTISEL","KEYS","F1")=""   ;"<--- NOTE: F1 handled by scroller, not by event handlers below
  NEW HIGHLINE SET HIGHLINE=+$GET(^TMG("TMP","SETTINGS","CONSOLE^TMGRX008"))
  IF HIGHLINE=0 SET HIGHLINE=5
  SET OPTION("HIGHLINE")=HIGHLINE
  ;                           
  ;"SET OPTION("ON CURSOR")="HNDONCSR^TMGRX008"
  SET OPTION("ON NEED DATA")="HNDONNEEDDATA^TMGRX008"
  SET OPTION("ON SELECT")="HNDONSEL^TMGRX008"
  SET OPTION("ON CMD")="HNDONCMD^TMGRX008"
  SET OPTION("ON KEYPRESS")="HNDONKP^TMGRX008"
  DO ADDNICECOLORS^TMGUSRIF(.OPTION,2)
  DO ADDRXCOLORS(.OPTION)   
  ;
  DO MASTER2RXARR("ARRAY",.OPTION)  ;
  ;
  SET OPTION("HEADER",1)=" - < Mangage medications > -"
  DO ADDFOOTER("^ to Exit",.OPTION)
  DO ADDFOOTERNAME("F1","SEL","Select",.OPTION)
  DO ADDFOOTERNAME("F2","DEL","Delete",.OPTION)
  DO SETMODELABELS(.OPTION) ;"set up F3=DETAILS, F4=PARSED
  DO SETMODE("DETAILS",0,.OPTION)   ;"[F3]
  DO SETMODE("PARSED",1,.OPTION)    ;"[F4]
  DO ADDFOOTERNAME("F5","MENU","Menu",.OPTION)
  DO ADDFOOTERNAME("F6","EDIT","Edit",.OPTION)
  DO ADDFOOTERNAME("F7","UTIL","Util",.OPTION)
  ;                                   
  ;"BELOW IS GOOD FOR DEBUGGING
  NEW ZZDEBUG SET ZZDEBUG=0
  IF ZZDEBUG=1 DO                    
  . SET OPTION("SCRN TOP OFFSET")=22
  . SET OPTION("SCRN HEIGHT")=25
  . SET OPTION("SCRN WIDTH")=130
  ;
  ;
  WRITE #
  DO SCROLLER^TMGUSRIF("ARRAY",.OPTION)
  ;
  ;"Save off cursor position. 
  SET ^TMG("TMP","SETTINGS","CONSOLE^TMGRX008")=+$GET(OPTION("HIGHLINE"))
  QUIT
  ;
ADDRXCOLORS(OPTION) ;
  NEW TMPWCLR
  NEW CLRBLUE SET CLRBLUE="CornflowerBlue"  
  ;"See WEBCOLORL1^TMGUSRI8 for other colors.     
  SET OPTION("COLORS","SELECTED")=$$COLOR24PAIR^TMGUSRI8("CornflowerBlue","Linen",.TMPWCLR)
  SET OPTION("COLORS","RX GENERIC")=$$COLOR24PAIR^TMGUSRI8("Firebrick","@",.TMPWCLR)
  SET OPTION("COLORS","RX BRAND")=$$COLOR24PAIR^TMGUSRI8("Red","@",.TMPWCLR)
  SET OPTION("COLORS","RX MOD")=$$COLOR24PAIR^TMGUSRI8("Purple","@",.TMPWCLR)
  SET OPTION("COLORS","RX FORM")=$$COLOR24PAIR^TMGUSRI8("LightSalmon","@",.TMPWCLR)
  SET OPTION("COLORS","RX STRENGTH")=$$COLOR24PAIR^TMGUSRI8("Red","@",.TMPWCLR)
  SET OPTION("COLORS","RX UNITS")=$$COLOR24PAIR^TMGUSRI8("Green","@",.TMPWCLR)
  SET OPTION("COLORS","RX SIG")=$$COLOR24PAIR^TMGUSRI8("Beige","@",.TMPWCLR)
  SET OPTION("COLORS","RX NOTE")=$$COLOR24PAIR^TMGUSRI8("Ivory","@",.TMPWCLR)
  SET OPTION("COLORS","RX OTC")=$$COLOR24PAIR^TMGUSRI8("Lime","@",.TMPWCLR)
  SET OPTION("COLORS","RX PREFACE")=$$COLOR24PAIR^TMGUSRI8("Cyan","@",.TMPWCLR)
  SET OPTION("COLORS","RX UNPARSED")=$$COLOR24PAIR^TMGUSRI8("LightGray","@",.TMPWCLR) 
  ;
  SET OPTION("COLORS","LINE NUMBERS")=$$COLOR24PAIR^TMGUSRI8("Gold","CornflowerBlue",.TMPWCLR)
  QUIT
  ;
MASTER2RXARR(PARRAY,OPTION)  ;
  ;"Purpose: To prepair an array with mes, for use with SCROLLER^TMGUSRIF
  ;"Input: PARRAY -- PASS BY NAME.  ARRAY to put info into.  Prior data is killed.
  ;"       OPTION -- PASS BY REFERENCE.  Prior data is NOT killed.  See SCROLLER^TMGUSRIF for details
  ;"                 OPTION("HIDE EMPTY")=0 OPTIONAL. Default is 0.  If 1 then, entries with no patches.
  ;"       OPTION("FILTER",<filter phrase>)=""  If found, then only lines that contain phrase will be shown.  
  ;"Results: NONE
  KILL @PARRAY
  NEW MASTERREF DO GETREFS^TMGRX002(.MASTERREF) 
  NEW IDX SET IDX=0
  KILL OPTION("USER","FILTERED RX LIST")  ;"will hold current, potentially-filtered, Rx list. 
  NEW LINE SET LINE=""
  FOR  SET LINE=$ORDER(@MASTERREF@(LINE)) QUIT:LINE=""  DO
  . IF $$LINEFILTERED(LINE,.OPTION) QUIT
  . SET @PARRAY@($I(IDX),LINE)=LINE
  . SET OPTION("USER","FILTERED RX LIST",IDX)=LINE  ;"<-- NOTE: IDX is 1:1 with data lines from @PARRAY
  . MERGE OPTION("USER","FILTERED RX LIST",IDX,"PAT DFN")=@MASTERREF@(LINE)  ;"1 or more DFN's as source of LINE
  KILL OPTION("USER","PARSED")  ;"will force repopulation in HNDONNEEDDATA event handler
  SET LISTCT=$$LISTCT^TMGMISC($NAME(OPTION("USER","FILTERED RX LIST")))
  IF $GET(OPTION("HIGHLINE"))>LISTCT DO
  . SET OPTION("HIGHLINE")=LISTCT  
  QUIT
  ;
LINEFILTERED(LINE,OPTION) ;"Determine if line should NOT be shown, based on filters. Copied from TMGPAT3B
  ;"Input: LINE -- a line of text to be evaluated
  ;"       OPTION -- Pass by REFERENCE.  Format:
  ;"           OPTION("FILTER",<filter phrase>)=""  If found, then only lines that contain phrase will be shown.  
  ;"Results: 1 if line should NOT be shown. 0 if OK to show  
  NEW RESULT SET RESULT=0
  IF '$DATA(OPTION("FILTER")) GOTO LFDN
  NEW ULINE SET ULINE=$$UP^XLFSTR(LINE)
  NEW PHRASE SET PHRASE=""
  FOR  SET PHRASE=$ORDER(OPTION("FILTER",PHRASE)) QUIT:(PHRASE="")!(RESULT=1)  DO
  . IF $EXTRACT(PHRASE,1)="!" DO
  . . NEW NEGPHRASE SET NEGPHRASE=$EXTRACT(PHRASE,2,$LENGTH(PHRASE))
  . . IF NEGPHRASE="" QUIT
  . . SET RESULT=(ULINE[NEGPHRASE)
  . ELSE  DO
  . . SET RESULT=(ULINE'[PHRASE)
LFDN ;  
  IF RESULT=1 DO
  . ;
  IF RESULT=0 DO
  . ;
  QUIT RESULT
  ;
TOGGLEMODE(NAME,OPTION) ;
  NEW STATE SET STATE=$$GETMODESTATE(NAME,.OPTION)
  NEW LABEL SET LABEL=$$GETLABEL(NAME,STATE,.OPTION) QUIT:LABEL=""
  NEW IDX SET IDX=$$FOOTERIDX(LABEL,.OPTION) QUIT:IDX'>0
  NEW NEWSTATE SET NEWSTATE='STATE
  NEW NEWLABEL SET NEWLABEL=$$GETLABEL(NAME,NEWSTATE,.OPTION) QUIT:NEWLABEL=""
  SET OPTION("FOOTER",1,IDX)=NEWLABEL  
  DO SETMODE(NAME,NEWSTATE,.OPTION)
  QUIT
  ;
SETMODE(NAME,STATE,OPTION)  ;
  NEW CUR SET CUR=$GET(OPTION("USER","MODE",NAME))
  IF CUR=STATE QUIT  ;"already at desired state
  SET STATE=($GET(STATE)=1)  ;"ensure boolean
  NEW NEGSTATE SET NEGSTATE='STATE  
  IF $DATA(OPTION("USER","MODE","LABELS",NAME))=0 DO SETMODELABELS(.OPTION)
  NEW LABEL MERGE LABEL=OPTION("USER","MODE","LABELS",NAME)
  IF $DATA(LABEL) DO
  . DO KILLFOOTER($$GETLABEL(NAME,NEGSTATE,.OPTION),.OPTION)
  . DO ADDFOOTER($$GETLABEL(NAME,STATE,.OPTION),.OPTION)
  . SET OPTION("USER","MODE",NAME)=STATE
  QUIT
  ;
GETLABEL(NAME,STATE,OPTION) ;
  IF $DATA(OPTION("USER","MODE","LABELS",NAME))=0 DO SETMODELABELS(.OPTION)
  NEW RESULT SET RESULT=$GET(OPTION("USER","MODE","LABELS",NAME,STATE))
  QUIT RESULT
  ;
SETMODELABELS(OPTION) ;
  ;"To do: Change to use OPTION("KEY_MAPPING"...
  NEW TEMP
  SET TEMP("DETAILS")="F3^DETAILS^Show details^Hide details"
  SET TEMP("PARSED")="F4^PARSED^Show Parsed^Show unparsed"
  NEW IDX SET IDX=""
  FOR  SET IDX=$ORDER(TEMP(IDX)) QUIT:IDX=""  DO
  . NEW LINE SET LINE=$GET(TEMP(IDX)) QUIT:LINE=""
  . NEW KEY SET KEY=$PIECE(LINE,"^",1)
  . NEW ACTION SET ACTION=$PIECE(LINE,"^",2)
  . SET OPTION("KEY_MAP",ACTION)=KEY
  . SET OPTION("KEY_MAP","XR",KEY)=ACTION
  . NEW STR 
  . SET STR(0)="["_KEY_"] "_$PIECE(LINE,"^",3)
  . SET STR(1)="["_KEY_"] "_$PIECE(LINE,"^",4)
  . MERGE OPTION("USER","MODE","LABELS",IDX)=STR
  QUIT
  ;
GETMODESTATE(NAME,OPTION) ;
  NEW RESULT SET RESULT=$GET(OPTION("USER","MODE",NAME),0)
  QUIT RESULT
  ;
SETFOOTER(STR,OPTION,ENABLE) ;"Add STR to Footer
  IF ENABLE DO 
  . DO ADDFOOTER(STR,.OPTION)
  ELSE  DO
  . DO KILLFOOTER(STR,.OPTION)  ;"Kill FN (e.g '[F3]') from Footer
  QUIT
  ;
ADDFOOTERNAME(KEY,ACTION,SHOWSTR,OPTION) ;
  ;"E.G.   DO ADDFOOTERNAME('F1','SEL','Select',.OPTION)
  NEW STR SET STR="["_KEY_"] "_SHOWSTR
  SET OPTION("KEY_MAP",ACTION)=KEY
  SET OPTION("KEY_MAP","XR",KEY)=ACTION
  DO ADDFOOTER(STR,.OPTION)
  QUIT
  ;
ADDFOOTER(STR,OPTION) ;"Add STR to Footer
  SET STR=$GET(STR) QUIT:STR=""
  NEW TMP SET TMP=$$FOOTERIDX(STR,.OPTION) QUIT:TMP>0  ;"don't add twice
  NEW MAXIDX SET MAXIDX=$ORDER(OPTION("FOOTER",1,""),-1)
  SET OPTION("FOOTER",1,MAXIDX+1)=STR
  QUIT;
  ;
KILLFOOTER(STR,OPTION)  ;"Kill STR (e.g '[F3]') from Footer
  SET STR=$GET(STR) QUIT:STR=""
  NEW IDX SET IDX=$$FOOTERIDX(STR,.OPTION)
  IF IDX>0 KILL OPTION("FOOTER",1,IDX)
  QUIT;
  ;
FOOTERIDX(STR,OPTION) ;"Return index in footer of STR
  NEW MAXIDX SET MAXIDX=$ORDER(OPTION("FOOTER",1,""),-1)
  NEW RESULT SET RESULT=0
  NEW IDX FOR IDX=1:1:MAXIDX DO  QUIT:(RESULT>0)
  . IF $GET(OPTION("FOOTER",1,IDX))[STR SET RESULT=IDX
  QUIT RESULT
  ;  
HNDONNEEDDATA(TMGPSCRLARR,OPTION,INFO)  ;
  ;"Input: TMGPSCRLARR -- PASS BY NAME.  See SCROLLER^TMGUSRIF for documentation
  ;"       OPTION -- PASSED BY REFERENCE.   See SCROLLER^TMGUSRIF for documentation 
  ;"       INFO -- passed by REFERENCE.     See SCROLLER^TMGUSRIF for documentation    
  ;"           Below is format for INFO variable, which is an IN and OUT parameter to call.  
  ;"           NOTE: This event is called ONCE per column per draw cycle.  It is NOT called per line.  So handler should provide results for visible cells in column
  ;"           If values in INFO shown below are modified, it will be used for data source.
  ;"           INFO("DATA","SELECTED",<COL#>)=<Selected Index of line>  I.e. what line is selected in column 1, 2, 3, etc.  
  ;"           INFO("DATA","SELECTED",<COL#>,"TEXT")=<Text of selected line>
  ;"                   NOTE: <COL#> will be 1..<CUR_COL>-1  I.e. columns to the LEFT of current column.  
  ;"           INFO("DATA","CUR COLUMN")=<COL#> for which data is being needed
  ;"           INFO("DATA","CUR COLUMN","START INDEX")=<LINE#> for beginning of lines of data which is needed
  ;"           INFO("DATA","CUR COLUMN","END INDEX")=<LINE#> for end of lines of data which is needed
  ;"           INFO("DATA","HANDLED")=1 if event handler has returned data.  If 0 then data will be obtained from legacy methods
  ;"           INFO("DATA","TEXT",<LINE#>)=<DISPLAY TEXT>  <--- event handler returns data for display here.    ;"
  ;"           INFO("DATA","TEXT",<LINE#>,"RETURN")=<A RETURN VALUE>  <--- event handler OPTIONALLY returns data here.
  NEW DRAWCOL SET DRAWCOL=+$GET(INFO("DATA","CUR COLUMN"))
  NEW CURLINE SET CURLINE=$GET(INFO("CURRENT LINE","NUMBER"))
  IF DRAWCOL=1 DO  GOTO HNDDN
  . NEW SHOULDPARSE SET SHOULDPARSE=$$GETMODESTATE("PARSED",.OPTION)
  . NEW STARTIDX SET STARTIDX=+$GET(INFO("DATA","CUR COLUMN","START INDEX"))
  . NEW ENDIDX SET ENDIDX=+$GET(INFO("DATA","CUR COLUMN","END INDEX"))
  . IF SHOULDPARSE DO
  . . NEW PARSEOPT SET PARSEOPT("FOR PATIENTS")=1,PARSEOPT("COLOR TAGS")=1
  . . NEW IDX FOR IDX=STARTIDX:1:ENDIDX DO
  . . . NEW ARR,LINE2,RETURN 
  . . . DO ENSURUSERPARSED(IDX,.OPTION,.RETURN,.LINE2)
  . . . ;"SET LINE2=$GET(OPTION("USER","PARSED",IDX,"FOR SCROLLER"),"?")
  . . . ;"SET RETURN=$GET(OPTION("USER","PARSED",IDX,"FOR SCROLLER","RETURN"))
  . . . ;"IF LINE2="?" DO
  . . . ;". NEW LINE SET LINE=$GET(OPTION("USER","FILTERED RX LIST",IDX))  ;"<-- NOTE: IDX is 1:1 with data lines from @PARRAY
  . . . ;". IF LINE="" SET LINE2=LINE QUIT
  . . . ;". DO PARSELN^TMGRX001(.ARR,LINE,0,.PARSEOPT)
  . . . ;". NEW DFNARR MERGE DFNARR=OPTION("USER","FILTERED RX LIST",IDX,"PAT DFN")
  . . . ;". MERGE ARR("PAT DFN")=DFNARR
  . . . ;". MERGE OPTION("USER","PARSED",IDX)=ARR
  . . . ;". SET LINE2=$$EXTERNAL^TMGRX003(.ARR,.PARSEOPT)
  . . . ;". SET OPTION("USER","PARSED",IDX,"FOR SCROLLER")=LINE2
  . . . ;". SET OPTION("USER","PARSED",IDX,"FOR SCROLLER","RETURN")=LINE
  . . . SET INFO("DATA","TEXT",IDX)=LINE2
  . . . IF RETURN'="" SET INFO("DATA","TEXT",IDX,"RETURN")=RETURN
  . ELSE  DO
  . . NEW IDX FOR IDX=STARTIDX:1:ENDIDX DO
  . . . NEW LINE SET LINE=$GET(OPTION("USER","FILTERED RX LIST",IDX))  ;"<-- NOTE: IDX is 1:1 with data lines from @PARRAY
  . . . SET INFO("DATA","TEXT",IDX)=LINE
  . . . SET INFO("DATA","TEXT",IDX,"RETURN")=LINE
  . SET INFO("DATA","HANDLED")=1
  IF DRAWCOL=2 DO  GOTO HNDDN
  . NEW ARR
  . NEW COL1SEL SET COL1SEL=+$GET(INFO("DATA","SELECTED",1))
  . NEW COL1LINE SET COL1LINE=$GET(OPTION("USER","FILTERED RX LIST",COL1SEL))
  . NEW LASTCOL1LINE SET LASTCOL1LINE=$GET(OPTION("USER","LASTCOL1LINE"))
  . IF COL1LINE=LASTCOL1LINE DO
  . . MERGE TMPDATA=OPTION("USER","LASTCOL1LINE","DATA")
  . . MERGE INFO("DATA","TEXT")=TMPDATA
  . ELSE  DO
  . . NEW PARSEOPT SET PARSEOPT("FOR PATIENTS")=1
  . . DO PARSELN^TMGRX001(.ARR,COL1LINE,0,.PARSEOPT)
  . . NEW LINE2 SET LINE2=$$EXTERNAL^TMGRX003(.ARR,.OPTION)
  . . NEW TMPDATA DO ARRDUMP^TMGMISC3("ARR",,,"TMPDATA")
  . . NEW IDX SET IDX=0
  . . FOR  SET IDX=$ORDER(TMPDATA(IDX)) QUIT:IDX'>0  DO
  . . . NEW LINE SET LINE=$GET(TMPDATA(IDX)) QUIT:LINE=""
  . . . SET LINE=$TRANSLATE(LINE,"{}","[]")
  . . . SET TMPDATA(IDX)=LINE
  . . MERGE INFO("DATA","TEXT")=TMPDATA
  . . SET OPTION("USER","LASTCOL1LINE")=COL1LINE
  . . KILL OPTION("USER","LASTCOL1LINE","DATA")
  . . MERGE OPTION("USER","LASTCOL1LINE","DATA")=TMPDATA
  . SET INFO("DATA","HANDLED")=1
HNDDN ;  
  QUIT
  ;
ENSURUSERPARSED(IDX,OPTION,RETURN,LINE2)  ;"Ensure cached values for parsed lines is ready
  ;"Input: IDX -- data index, same as cursor line
  ;"       OPTION -- pass by reference.  The array with all the user data etc. 
  ;'       RETURN -- AN OUT PARAMETER
  ;"       LINE2 -- AN OUT PARAMETER
  ;"RESULT: none
  NEW ARR
  SET LINE2=$GET(OPTION("USER","PARSED",IDX,"FOR SCROLLER"),"?")
  SET RETURN=$GET(OPTION("USER","PARSED",IDX,"FOR SCROLLER","RETURN"))
  IF LINE2="?" DO
  . NEW PARSEOPT SET PARSEOPT("FOR PATIENTS")=1,PARSEOPT("COLOR TAGS")=1
  . NEW LINE SET LINE=$GET(OPTION("USER","FILTERED RX LIST",IDX))  ;"<-- NOTE: IDX is 1:1 with data lines from @PARRAY
  . IF LINE="" SET LINE2=LINE QUIT
  . DO PARSELN^TMGRX001(.ARR,LINE,0,.PARSEOPT)
  . NEW DFNARR MERGE DFNARR=OPTION("USER","FILTERED RX LIST",IDX,"PAT DFN")
  . MERGE ARR("PAT DFN")=DFNARR
  . MERGE OPTION("USER","PARSED",IDX)=ARR
  . SET LINE2=$$EXTERNAL^TMGRX003(.ARR,.PARSEOPT)
  . SET OPTION("USER","PARSED",IDX,"FOR SCROLLER")=LINE2
  . SET OPTION("USER","PARSED",IDX,"FOR SCROLLER","RETURN")=LINE
  QUIT
  ;
HNDONCSR(TMGPSCRLARR,OPTION,INFO)  ;"DEPRECIATED
  ;"Purpose: Handle ON CURSOR event from SCROLLER
  ;"         Event is fired when a cursor key is pressed, before the scroller moves the highlighted line.  
  ;"Input: TMGPSCRLARR,OPTION,INFO -- see documentation in SCROLLER
  ;"       INFO has this:
  ;"          INFO("CURSOR")=Cursor Key pressed
  ;"          INFO("CURSOR","HANDLED")=1 <-- this is what called code should set if it handled
  ;"                          the cursor event. This will prevent scroller from acting on it.     
  NEW CURSOR SET CURSOR=$GET(INFO("CURSOR"))
  IF "LEFT,RIGHT,HOME,END,"'[CURSOR QUIT
  NEW ACTIVECOL SET ACTIVECOL=+$GET(OPTION("COLUMNS","ACTIVE"),1)
  NEW MAXCOLS SET MAXCOLS=+$GET(OPTION("COLUMNS","NUM"),1)
  NEW CMDIDX SET CMDIDX=0
  IF CURSOR="RIGHT" DO  GOTO HCSR3L2
  . IF 0=1,ACTIVECOL>=MAXCOLS DO  ;"SET UP A NEW COLUMN.
  . . SET CMDIDX=$$ADDDOFN(.INFO,"ADD COLUMN(1)")   ;"1 --> AUTO SET COL WIDTHS
  . . NEW IDX SET IDX=$SELECT((ACTIVECOL+1)#2=0:2,1:1)  ;"If To-be-added column number will be EVEN --> 2, otherwise 1
  . . IF (ACTIVECOL+1)=2 QUIT  ;"COL 2 has colors set up in ADDNICECOLORS, called in DEMODYNCOLS
  . . NEW DATAREF SET DATAREF=$NAME(INFO("DO FUNCTION",CMDIDX,"DATA"))
  . . IF IDX=1 MERGE @DATAREF@("COLORS")=OPTION("COLORS")
  . . ELSE  MERGE @DATAREF@("COLORS")=OPTION("COLUMNS",IDX,"COLORS")
  . ELSE  SET ACTIVECOL=ACTIVECOL+1
  IF CURSOR="LEFT" DO  GOTO HCSR3L2
  . IF ACTIVECOL>1 DO
  . . SET ACTIVECOL=ACTIVECOL-1
  IF CURSOR="END" DO  GOTO HCSR3L2
  . SET CMDIDX=$$ADDDOFN(.INFO,"SCROLL VIEWPORT(1)")  
  IF CURSOR="HOME" DO  GOTO HCSR3L2
  . SET CMDIDX=$$ADDDOFN(.INFO,"SCROLL VIEWPORT(-1)")
HCSR3L2 ;  
  SET TMGSCLRMSG="FULL"  
  SET OPTION("COLUMNS","ACTIVE")=ACTIVECOL
  SET INFO("CURSOR","HANDLED")=1
  QUIT                                            
  ;
ADDDOFN(INFO,NAME) ;"ADD DO FUNCTION
  NEW IDX SET IDX=$ORDER(INFO("DO FUNCTION",""),-1)+1
  SET INFO("DO FUNCTION",IDX)=NAME
  QUIT IDX
  ;
HNDONSEL(PARRAY,OPTION,INFO)  ;
  ;"Purpose: handle ON SELECT event from SCROLLER^TMGUSRIF
  ;"Input: PARRAY,OPTION,INFO -- see documentation in SCROLLER^TMGUSRIF
  NEW KEY SET KEY=$GET(OPTION("KEY_MAP","MENU"),"?")
  SET INFO("USER INPUT")="{"_KEY_"}"
  DO HNDONCMD(.PARRAY,.OPTION,.INFO)
  QUIT
  ;
HNDONKP(PARRAY,OPTION,INFO)  ;
  ;"Purpose: handle ON KEYPRESS event from SCROLLER^TMGUSRIF
  ;"Input: PARRAY,OPTION,INFO -- see documentation in SCROLLER^TMGUSRIF
  NEW INPUT SET INPUT=$GET(INFO("USER INPUT"))
  NEW PASSON SET PASSON=INPUT["{"
  IF PASSON,INPUT="{BACKSPC}" SET PASSON=0
  IF INPUT="{REMOVE}" DO
  . IF $GET(OPTION("KEY_MAP","DEL"))="" QUIT
  . SET INFO("USER INPUT")="{"_OPTION("KEY_MAP","DEL")_"}"
  IF PASSON DO
  . DO HNDONCMD(.PARRAY,.OPTION,.INFO)
  ELSE  DO                          
  . NEW CMD SET CMD=$GET(INFO("CMD"))
  . NEW OPT2 SET OPT2("TRIM DIV")=1
  . NEW ARR DO SPLIT2AR^TMGSTUT2(CMD," ",.ARR,1,.OPT2)
  . KILL OPTION("FILTER") 
  . NEW IDX SET IDX=0
  . FOR  SET IDX=$ORDER(ARR(IDX)) QUIT:IDX'>0  DO
  . . NEW PHRASE SET PHRASE=$$UP^XLFSTR($GET(ARR(IDX))) QUIT:PHRASE=""
  . . SET OPTION("FILTER",PHRASE)=""
  . DO MASTER2RXARR(PARRAY,.OPTION)
  QUIT
  ;
HNDONCMD(PARRAY,OPTION,INFO)  ;
  ;"Purpose: handle ON SELECT event from Scroller
  ;"Input: PARRAY -- see documentation in Scroller
  ;"       OPTION: Includes:      -- see documentation in Scroller
  ;"         OPTION("KEY_MAPPING",<ACTION_NAME>)=<FUNCTION KEY, E.G. F2>
  ;"         OPTION("KEY_MAPPING","XR",<FUNCTION KEY, E.G. F2>)=<ACTION_NAME>
  ;"       INFO has this:      -- see documentation in Scroller
  ;"          INFO("USER INPUT")=INPUT
  ;"          INFO("CURRENT LINE","NUMBER")=number currently highlighted line
  ;"          INFO("CURRENT LINE","TEXT")=Text of currently highlighted line
  ;"          INFO("CURRENT LINE","RETURN")=return value of currently highlighted line
  ;
  NEW INPUT SET INPUT=$GET(INFO("USER INPUT"))
  NEW IDX SET IDX=$GET(INFO("CURRENT LINE","NUMBER")) QUIT:IDX'>0
  NEW PARSEDARR MERGE PARSEDARR=OPTION("USER","PARSED",IDX)  ;"NOTE: This might be EMPTY(!) if user never has enabled parsed mode
  NEW CURLINE SET CURLINE=$GET(PARSEDARR("FOR SCROLLER","RETURN"))
  NEW KEY SET KEY=$PIECE($PIECE(INPUT,"{",2),"}",1)
  NEW ACTION SET ACTION=$GET(OPTION("KEY_MAP","XR",KEY))
  IF ACTION="DEL" DO   ;"DELETE
  . DO DELSELECTED(PARRAY,.OPTION) 
  ELSE  IF ACTION="DETAILS" DO  ;"TOGGLE DETAILS
  . DO TOGGLEMODE("DETAILS",.OPTION) ;
  . NEW NUMCOLS SET NUMCOLS=+$GET(OPTION("COLUMNS","NUM"),1)
  . NEW STATE SET STATE=$$GETMODESTATE("DETAILS",.OPTION)
  . NEW NEWNUMCOLS SET NEWNUMCOLS=$SELECT(STATE=1:2,1:1)
  . IF NUMCOLS>NEWNUMCOLS DO
  . . IF $$ADDDOFN(.INFO,"DROP COLUMN")   ;"ignore result  
  . ELSE  IF NEWNUMCOLS>NUMCOLS DO
  . . IF $$ADDDOFN(.INFO,"ADD COLUMN")   ;"ignore result  
  ELSE  IF ACTION="PARSED" DO   ;"TOGGLE PARSED
  . DO TOGGLEMODE("PARSED",.OPTION) ;      
  ELSE  IF ACTION="MENU" DO  ;"ACTION MENU
  . NEW COL1SEL SET COL1SEL=+$GET(INFO("DATA","SELECTED",1))
  . IF COL1SEL'>0 SET COL1SEL=+$GET(INFO("CURRENT LINE","NUMBER"))
  . NEW COL1LINE SET COL1LINE=$GET(OPTION("USER","FILTERED RX LIST",COL1SEL))
  . SET ^TMP("PARSELN^TMGRX001",$J)=COL1LINE
  . DO ACTIONMENU(.OPTION,PARRAY,.PARSEDARR)
  . DO MASTER2RXARR(PARRAY,.OPTION)  ;
  . KILL OPTION("USER","PARSED")  ;"will force repopulation in HNDONNEEDDATA event handler  
  . SET TMGSCLRMSG="FULL"  
  ELSE  IF ACTION="EDIT" DO  ;"Edit Rx line
  . DO EDITRXLINE2(CURLINE,PARRAY,.PARSEDARR,.OPTION)
  ELSE  IF ACTION="UTIL" DO  ;"Utility menu
  . DO UTILMENU(.OPTION,PARRAY)
  QUIT  
  ;
DELSELECTED(PARRAY,OPTION) ;"
  NEW SELARR DO GETSELECTED^TMGUSRIF(.SELARR,PARRAY)
  NEW PARSED SET PARSED=$$GETMODESTATE("PARSED",.OPTION)
  NEW LINENODE SET LINENODE=$SELECT(PARSED:2,1:1)
  NEW ARR2
  NEW IDX SET IDX=0
  FOR  SET IDX=$ORDER(SELARR(1,IDX)) QUIT:IDX'>0  DO
  . NEW LINE SET LINE=$GET(SELARR(1,IDX,LINENODE)) QUIT:LINE=""
  . SET ARR2(IDX)=LINE
  NEW CT SET CT=$$LISTCT^TMGMISC("ARR2")
  WRITE !,!
  IF CT=0 DO  GOTO DSDN
  . WRITE "Nothing selected for deletion!",!
  . DO PRESS2GO^TMGUSRI2
  NEW % SET %=1
  WRITE "Delete ",CT," medications from active examples list" DO YN^DICN WRITE !
  IF %'=1 GOTO DSDN
  ;"HERE I WILL DO ACTUAL DELETION.  
  NEW MASTERREF,DONEREF,DELREF,CURREF
  DO GETREFS^TMGRX002(.MASTERREF,.DONEREF,.DELREF,.CURREF) 
  SET IDX=0
  FOR  SET IDX=$ORDER(ARR2(IDX)) QUIT:IDX'>0  DO
  . KILL OPTION("USER","FILTERED RX LIST",IDX)  ;"<-- NOTE: IDX is 1:1 with data lines from @PARRAY
  . NEW LINE SET LINE=$GET(ARR2(IDX)) QUIT:LINE=""
  . MERGE @DELREF@(LINE)=@MASTERREF@(LINE)
  . KILL @MASTERREF@(LINE)
  . KILL @CURREF@(LINE)
  . KILL @PARRAY@(IDX)
  . KILL @PARRAY@("SELECTED",IDX)
  . KILL OPTION("USER","PARSED",IDX)
  DO MASTER2RXARR("ARRAY",.OPTION)  ;
DSDN ;  
  DO CPL^TMGTERM(1)
  WRITE "                                                                         "
  QUIT 
  ;
UTILMENU(OPTION,PARRAY)  ;  
  NEW MENU,IDX,ONOFF
  NEW MASTERREF DO GETREFS^TMGRX002(.MASTERREF)   
UML1 ;          
  WRITE #
  SET IDX=0  
  KILL MENU SET MENU(IDX)="Select Menu Option"
  ;
  SET IDX=IDX+1,MENU(IDX)="Repopulate Rx list from patients"_$CHAR(9)_"RELOAD"
  SET IDX=IDX+1,MENU(IDX)="Repopulate Rx list from patients from PAST WEEK"_$CHAR(9)_"LAST_WEEK"
  SET IDX=IDX+1,MENU(IDX)="Repopulate Rx list from patients with appts in UPCOMING WEEK"_$CHAR(9)_"UPCOMING_WEEK"
  SET IDX=IDX+1,MENU(IDX)="Repopulate Rx list from scheduled patients"_$CHAR(9)_"SCHEDULE"
  SET IDX=IDX+1,MENU(IDX)="Repopulate Rx list from ONE SELECTED PATIENT"_$CHAR(9)_"ONE_PT"
  SET IDX=IDX+1,MENU(IDX)="Jump to line#"_$CHAR(9)_"JUMP"
  SET ONOFF=$SELECT($GET(OPTION("LINE NUMBERS")):"OFF",1:"ON")
  SET IDX=IDX+1,MENU(IDX)="Toggle line numbers "_ONOFF_$CHAR(9)_"LINENUMS"  
  SET USRPICK=$$MENU^TMGUSRI2(.MENU,"^")
  IF USRPICK="^" GOTO UMDN
  IF USRPICK="RELOAD" DO  GOTO UMDN
  . DO BIGLIST^TMGRX002(MASTERREF)  
  . DO MASTER2RXARR(PARRAY,.OPTION)  
  IF USRPICK="LAST_WEEK" DO  GOTO UMDN
  . NEW SDT SET SDT=$$ADDDAYS^TMGDATE("-7")
  . NEW EDT SET EDT=$$ADDDAYS^TMGDATE("0")
  . NEW OPT SET OPT("EXCLUDE INACTIVE")=1,OPT("CHECK APPT")=1  
  . KILL @MASTERREF  
  . DO CUSTLIST^TMGRX002(MASTERREF,SDT,EDT,.OPT)
  . DO MASTER2RXARR(PARRAY,.OPTION) 
  IF USRPICK="UPCOMING_WEEK" DO  GOTO UMDN
  . NEW SDT SET SDT=$$ADDDAYS^TMGDATE("0")
  . NEW EDT SET EDT=$$ADDDAYS^TMGDATE("7")
  . NEW OPT SET OPT("EXCLUDE INACTIVE")=1,OPT("CHECK APPT")=1  
  . KILL @MASTERREF  
  . DO CUSTLIST^TMGRX002(MASTERREF,SDT,EDT,.OPT)
  . DO MASTER2RXARR(PARRAY,.OPTION) 
  IF USRPICK="ONE_PT" DO  GOTO UMDN
  . NEW RESULT SET RESULT=0
  . NEW X,Y,DIC SET DIC=2,DIC(0)="MAEQ"
  . DO ^DIC WRITE !
  . IF +Y'>0 QUIT
  . KILL @MASTERREF  
  . NEW PTLIST SET PTLIST(+Y)=""
  . DO GETBLIST^TMGRX002(MASTERREF,.PTLIST)  
  . DO MASTER2RXARR(PARRAY,.OPTION) 
  IF USRPICK="JUMP" DO  GOTO UMDN
  . NEW HIGHLINE SET HIGHLINE=+$GET(OPTION("HIGHLINE"))
  . NEW MSG 
  . SET MSG(1)="Jump to line number"
  . SET MSG(2)="Enter Target Line #"
  . NEW DLGOPT SET DLGOPT("ALT BUFFER")=1,DLGOPT("INIT VALUE")=HIGHLINE
  . NEW TMP,CLR DO ADDNICECOLORS^TMGUSRIF(.TMP) 
  . SET CLR=$GET(TMP("COLORS","NORM"))
  . DO SPLITCOLOR2REF^TMGUSRI8(CLR,$NAME(DLGOPT("COLOR")))
  . SET CLR=$GET(TMP("COLORS","HEADER"))
  . DO SPLITCOLOR2REF^TMGUSRI8(CLR,$NAME(DLGOPT("COLOR","EDITOR")))    
  . SET HIGHLINE=$$EDITDLG^TMGUSRI6(.MSG,.DLGOPT) QUIT:HIGHLINE'>0
  . SET OPTION("HIGHLINE")=+HIGHLINE  
  IF USRPICK="LINENUMS" DO  GOTO UML1
  . SET OPTION("LINE NUMBERS")='$GET(OPTION("LINE NUMBERS"))
  GOTO UML1
UMDN ;  
  QUIT
  ;
  ;"===================================
ACTIONMENU(OPTION,PARRAY,PARSEDARR)  ;
  NEW MASTERREF,DONEREF,DELREF DO GETREFS^TMGRX002(.MASTERREF,.DONEREF,.DELREF) 
  NEW MENU,IDX,LISTCT,DONE
  ;"SET CURLINE=$GET(^TMP("PARSELN^TMGRX001",$J))
  DO ENSURPARSEDARR(.PARSEDARR,.OPTION)
  NEW CURLINE SET CURLINE=$GET(PARSEDARR("FOR SCROLLER","RETURN"))
  IF CURLINE="" DO
  . NEW DATAIDX SET DATAIDX=+$GET(OPTION("HIGHLINE"))
  . SET CURLINE=$GET(OPTION("USER","FILTERED RX LIST",DATAIDX))
CSL1 ;          
  WRITE #
  SET IDX=0  
  KILL MENU SET MENU(IDX)="Select Menu Option"
  SET MENU(IDX,1)="Rx: "_CURLINE
  ;
  SET IDX=IDX+1,MENU(IDX)="Edit Matched medication record"_$CHAR(9)_"EDIT_MATCHED"
  SET IDX=IDX+1,MENU(IDX)="Edit Other medication record"_$CHAR(9)_"EDIT_OTHER"
  SET IDX=IDX+1,MENU(IDX)="Dump (examine) a medication mapping record"_$CHAR(9)_"DUMP"
  SET IDX=IDX+1,MENU(IDX)="Recompile example meds from ALL PATIENTS' meds"_$CHAR(9)_"BIGLIST"
  ;"SET IDX=IDX+1,MENU(IDX)="Check, Register Rx"_$CHAR(9)_"CHECKREGRX"
  SET IDX=IDX+1,MENU(IDX)="Check, Register Rx (Interactive mode)"_$CHAR(9)_"CHECKREGRX_INTERACTIVE"
  SET IDX=IDX+1,MENU(IDX)="Check, Register Rx (Debug mode)"_$CHAR(9)_"CHECKREGRX_DEBUG"
  SET IDX=IDX+1,MENU(IDX)="Debug parsing current Rx"_$CHAR(9)_"DEBUG"
  SET IDX=IDX+1,MENU(IDX)="Debug recreating external form for Rx"_$CHAR(9)_"EXTERNAL"
  SET IDX=IDX+1,MENU(IDX)="Toggle output mode to 'For Patients' "_$SELECT($GET(OPTION("FOR PATIENTS")):"OFF",1:"ON")_$CHAR(9)_"TOGGLEFORPT"
  SET IDX=IDX+1,MENU(IDX)="Toggle output mode to 'COLOR TAGS' "_$SELECT($GET(OPTION("COLOR TAGS")):"OFF",1:"ON")_$CHAR(9)_"TOGGLECOLORTAGS"
  SET IDX=IDX+1,MENU(IDX)="Find SOURCE of erroneous Rx"_$CHAR(9)_"FIND_RX"  
  SET IDX=IDX+1,MENU(IDX)="More options"_$CHAR(9)_"MORE"
  SET USRPICK=$$MENU^TMGUSRI2(.MENU,"^")
  IF USRPICK="^" GOTO CLSDN
  IF USRPICK="EDIT_MATCHED" DO  GOTO CSL1
  . SET OPTION("FORCE EDIT")=1
  . DO CHKREGRX^TMGRX005(CURLINE,,0,.OPTION)
  . KILL OPTION("FORCE EDIT")
  IF USRPICK="EDIT_OTHER" DO  GOTO CSL1
  . NEW DIC,X,Y SET DIC=22733,DIC(0)="MAEQ"
  . SET Y=$PIECE(USRPICK,"^",2)
  . IF Y="NEW" SET DIC(0)=DIC(0)_"L"  ;"LAYGO
  . IF Y'>0 WRITE ! DO ^DIC QUIT:Y'>0
  . DO EDITRX^TMGRX005(+Y)
  IF USRPICK="BIGLIST" DO  GOTO CSL1
  . SET %=2 WRITE "Repopulate the big list of examples"
  . DO YN^DICN WRITE !
  . IF %'=1 QUIT
  . NEW REF SET REF=$NAME(^TMG("TMP","EXAMPLE MEDS"))
  . DO BIGLIST^TMGRX002(REF)
  . ;"KILL RXLIST MERGE RXLIST=@REF
  . WRITE !
  IF USRPICK="CHECKREGRX" DO  GOTO CSL1
  . DO CHKREGRX^TMGRX005(CURLINE,,1,.OPTION)
  IF USRPICK="CHECKREGRX_INTERACTIVE" DO  GOTO CSL1
  . DO CHKREGRX^TMGRX005(CURLINE,,2,.OPTION)
  IF USRPICK="CHECKREGRX_DEBUG" DO  GOTO CSL1
  . NEW ARR NEW CODE SET CODE="DO CHKREGRX^TMGRX005(CURLINE,,2,.OPTION)"
  . DO DIRDEBUG^TMGIDE(CODE)
  . DO PRESS2GO^TMGUSRI2
  IF $PIECE(USRPICK,"^",1)="DUMP" DO  GOTO CSL1
  . NEW IENS SET IENS=$PIECE(USRPICK,"^",2) IF IENS'="" SET IENS=IENS_","
  . NEW OPTION SET OPTION("NO LOOP")=1
  . DO ASKDUMP^TMGDEBU3(22733,IENS,.OPTION)
  IF USRPICK="MORE" DO  GOTO CSL1
  . DO CHKREGRX^TMGRX005("")   
  IF USRPICK="DEBUG" DO  GOTO CSL1
  . NEW ARR NEW CODE SET CODE="DO PARSELN^TMGRX001(.ARR,CURLINE,1,.OPTION)"
  . DO DIRDEBUG^TMGIDE(CODE)
  . WRITE !,"Output of debug session would be:",!
  . NEW LINE2 SET LINE2=$$EXTERNAL^TMGRX003(.ARR,.OPTION)
  . WRITE LINE2,!
  . DO PRESS2GO^TMGUSRI2
  IF USRPICK="EXTERNAL" DO  GOTO CSL1
  . NEW ARR DO PARSELN^TMGRX001(.ARR,CURLINE,0,.OPTION)
  . NEW LINE2 NEW CODE SET CODE="SET LINE2=$$EXTERNAL^TMGRX003(.ARR,.OPTION)"
  . DO DIRDEBUG^TMGIDE(CODE)
  . WRITE !,"Output of debug session would be:",!
  . WRITE LINE2,!
  . DO PRESS2GO^TMGUSRI2
  IF USRPICK="TOGGLECOLORTAGS" DO  GOTO CSL1
  . SET OPTION("COLOR TAGS")='$GET(OPTION("COLOR TAGS"))
  IF USRPICK="TOGGLEFORPT" DO  GOTO CSL1
  . SET OPTION("FOR PATIENTS")='$GET(OPTION("FOR PATIENTS"))
  IF USRPICK="FIND_RX" SET DONE=0 DO  GOTO CLSDN:DONE,CSL1
  . SET DONE=$$EDITRXLINE(CURLINE,PARRAY,.PARSEDARR)
  GOTO CSL1
  ;
CLSDN ;
  QUIT;
  ;
ENSURPARSEDARR(PARSEDARR,OPTION)  ;"Ensure PARSEDARR has appropriate values
  NEW DATAIDX SET DATAIDX=+$GET(OPTION("HIGHLINE")) QUIT:DATAIDX'>0
  SET CURLINE=$GET(OPTION("USER","FILTERED RX LIST",DATAIDX)) QUIT:CURLINE=""
  IF $DATA(PARSEDARR)=0 DO
  . DO ENSURUSERPARSED(DATAIDX,.OPTION)  ;"Ensure cached values for parsed lines is ready  
  . MERGE PARSEDARR=OPTION("USER","PARSED",IDX)  ;"NOTE: This might be EMPTY if user never has enabled parsed mode
  IF $DATA(PARSEDARR("PAT DFN"))=0 DO
  . MERGE PARSEDARR("PAT DFN")=OPTION("USER","FILTERED RX LIST",DATAIDX,"PAT DFN")
  QUIT
  ;
EDITRXLINE(LINE,PARRAY,PARSEDARR) ;
  ;"INPUT:  LINE -- unparsed line as seen in scroller (all upper case)
  ;"        PARRAY -- name of arry holding scroller data
  ;"        PARSEDARR -- array as generated by parser.  Includes:
  ;"          PARSEDARR("PAT DFN",<PATIENT IEN>)=""
  ;"          PARSEDARR("PAT DFN","SRC")=<original line, case unchanged>
  ;"INPUT: Current Rx line, as found in list of examples
  ;"Result: 1 if line was changed.  
  NEW MASTERREF,DONEREF,DELREF DO GETREFS^TMGRX002(.MASTERREF,.DONEREF,.DELREF)   
  NEW DFNARR
  ;"DO SRCHBIGLIST^TMGRX002(.DFNARR,MASTERREF,CURLINE) WRITE !
  MERGE DFNARR=PARSEDARR("PAT DFN")
  NEW ORIGLINE SET ORIGLINE=$GET(DFNARR("SRC"))
  NEW ABORT SET ABORT=0
  NEW PTFOUND SET PTFOUND=0
  NEW TMGDFN SET TMGDFN=0
  FOR  SET TMGDFN=$ORDER(DFNARR(TMGDFN)) QUIT:(TMGDFN'>0)!ABORT  DO
  . SET PTFOUND=1
  . NEW DELTA DO EDITRXTBL^TMGRX007(TMGDFN,.DELTA)
  . ;"TO DO -- REMOVE ALL ENTRIES FROM DELTA(1,*) FROM MASTERREF, AND ADD DELTA(2,*) ENTRIES.
  . NEW LINE SET LINE=""
  . FOR  SET LINE=$ORDER(DELTA(1,LINE)) QUIT:LINE=""  DO
  . . NEW TMP SET TMP=$$UP^XLFSTR(LINE)
  . . NEW INFO MERGE INFO=@MSTERREF@(TMP)
  . . KILL @MASTERREF@(TMP)
  . SET LINE=""
  . FOR  SET LINE=$ORDER(DELTA(2,LINE)) QUIT:LINE=""  DO
  . . NEW TMP SET TMP=$$UP^XLFSTR(LINE)
  . . SET @MASTERREF@(TMP)=""
  . DO MASTER2RXARR(PARRAY,.OPTION)
  . SET QUIT=1
  IF PTFOUND=0 DO  QUIT
  . WRITE "Could not find patient for this medication.",!
  . DO PRESS2GO^TMGUSRI2
  QUIT
  ;
EDITRXLINE2(LINE,PARRAY,PARSEDARR,OPTION) ;
  ;"INPUT:  LINE -- unparsed line as seen in scroller (all upper case)
  ;"        PARRAY -- name of arry holding scroller data
  ;"        PARSEDARR -- array as generated by parser.  Includes:
  ;"          PARSEDARR("PAT DFN",<PATIENT IEN>)=""
  ;"          PARSEDARR("PAT DFN","SRC")=<original line, case unchanged>
  ;"INPUT: Current Rx line, as found in list of examples
  ;"Result: 1 if line was changed.  
  NEW MASTERREF,DONEREF,DELREF DO GETREFS^TMGRX002(.MASTERREF,.DONEREF,.DELREF)   
  DO ENSURPARSEDARR(.PARSEDARR,.OPTION)  ;"Ensure PARSEDARR has appropriate values
  NEW DFNARR
  ;"DO SRCHBIGLIST^TMGRX002(.DFNARR,MASTERREF,CURLINE) WRITE !
  MERGE DFNARR=PARSEDARR("PAT DFN")
  NEW ORIGLINE SET ORIGLINE=$GET(DFNARR("SRC"))
  NEW ABORT SET ABORT=0
  NEW PTFOUND SET PTFOUND=0
  NEW TMGDFN SET TMGDFN=0
  FOR  SET TMGDFN=$ORDER(DFNARR(TMGDFN)) QUIT:(TMGDFN'>0)!ABORT  DO
  . SET PTFOUND=1
  . NEW DELTA DO EDITRXLN^TMGRX007(TMGDFN,ORIGLINE,.DELTA,.OPTION)
  . ;"Change @MASTERREF so scroller display etc shows edits.  
  . NEW LINE,UPLINE
  . SET LINE=$ORDER(DELTA(1,"")) QUIT:LINE=""
  . SET UPLINE=$$UP^XLFSTR(LINE)
  . KILL @MASTERREF@(UPLINE)
  . SET LINE=$ORDER(DELTA(2,"")) 
  . IF LINE'="" DO 
  . . SET UPLINE=$$UP^XLFSTR(LINE)
  . . SET @MASTERREF@(UPLINE)=""
  . . SET @MASTERREF@(UPLINE,TMGDFN,"SRC")=LINE
  . DO MASTER2RXARR(PARRAY,.OPTION)
  . SET QUIT=1
  IF PTFOUND=0 DO  QUIT
  . WRITE "Could not find patient for this medication.",!
  . DO PRESS2GO^TMGUSRI2
  QUIT
  