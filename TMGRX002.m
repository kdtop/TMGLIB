TMGRX002 ;TMG/kst/Patient medication code; 08/23/17, 3/24/21
       ;;1.0;TMG-LIB;**1**;08/23/17
 ;       
 ;"Code for handling parsed medication array
 ;"~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--
 ;"Copyright (c) 08/23/17  Kevin S. Toppenberg MD
 ;"
 ;"This file is part of the TMG LIBRARY, and may only be used in accordence
 ;" to license terms outlined in separate file TMGLICNS.m, which should 
 ;" always be distributed with this file.
 ;"~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--
 ;
 ;"=======================================================================
 ;" API -- Public Functions.
 ;"=======================================================================
 ;"CONSOLE -- master entry point for training and testing system.   
 ;
 ;"=======================================================================
 ;"PRIVATE API FUNCTIONS
 ;"=======================================================================
 ;"GETREFS(MASTERREF,DONEREF,DELREF) ;
 ;"BIGLIST -- Gather a list of all possible med lines, for testing
 ;"GETBLIST(REF) -- Get a big list of meds, based on the med tables from ALL patients
 ;"GETRXLST(OUT,REF)  -- GET RX LIST
 ;"SAVRXLST(OUT)  -- SAVE RX LIST
 ;"VIEWLST(LIST) -- VIEW LIST OF MEDICATIONS
 ;"SELRX -- Pick meds from list, for testing parsing.  
 ;"SELRX2(OUT,REF,DONEREF,OPTION) -- CHECK WHICH PARSES ARE GOOD. 
 ;"DELRXLST(LIST,MASTERREF,DELREF,OPTION)  -- DELETE SELECTED ITEMS, CONTAINED IN LIST.  
 ;"SELRX3(MASTERREF,DONEREF,OPTION) -- CHECK WHICH 'DONE'/COMPLETED parses need to be put back into pending list.   
 ;"GETMTLST(OUT) -- GET RXLIST FROM PATIENT'S MEDICATION TABLE
 ;"T2 -- Test just 1 sample line for testing
 ;"FIX1  ;
 ;"FIX2  ;
 ;"FIX3  ;
 ;"FIX4  ;
 ;"ASKUNDEL ;
 ;"UNDEL(LINE) ;
 ;"GTHTMOUT(OUTREF)  --GET HTML FOR AN OUTPUT FILE.  
 ;"R(RESULT,ARGS) ; GET web page view   -- Modified from R^TMGRST02
 ;"=======================================================================
 ;"DEPENDENCIES
 ;"=======================================================================
 ;"Uses:  
 ;"=======================================================================
 ;      
CONSOLE  ;"
  NEW MASTERREF,DONEREF,DELREF DO GETREFS(.MASTERREF,.DONEREF,.DELREF) 
  NEW MENU,IDX,RXLIST,LISTCT,OPTION
  MERGE RXLIST=^TMP("CONSOLE^TMGRX002",$J)
CSL1 ;          
  SET IDX=0  
  SET LISTCT=$SELECT($DATA(RXLIST)=0:0,1:$$LISTCT^TMGMISC2("RXLIST"))
  KILL MENU SET MENU(IDX)="Select Option For Managing Medications Fix System"
  SET MENU(IDX,1)="Current RX LIST has "_LISTCT_" entries"
  NEW RXREF SET RXREF=$NAME(^TMP("MEDIEN2^TMGRX004",$J)) KILL @RXREF  ;"FORCE REFRESH OF MEDS AFTER EDITING ETC.
  ;
  IF LISTCT'>0 SET IDX=IDX+1,MENU(IDX)="Select RX LIST"_$CHAR(9)_"GETLIST"
  IF LISTCT'>0 SET IDX=IDX+1,MENU(IDX)="Select Patient's medication table for RX LIST"_$CHAR(9)_"GETPTMEDLIST"
  ELSE  SET IDX=IDX+1,MENU(IDX)="CLEAR RX LIST"_$CHAR(9)_"CLEAR"
  IF LISTCT>0 SET IDX=IDX+1,MENU(IDX)="View current RX LIST"_$CHAR(9)_"VIEWLIST"
  IF LISTCT>0 SET IDX=IDX+1,MENU(IDX)="TRAIN with medication entries (RX LIST)"_$CHAR(9)_"TRAIN"
  IF LISTCT>0 SET IDX=IDX+1,MENU(IDX)="TEST (and COMPLETE) medication entries (RX LIST)"_$CHAR(9)_"TEST"
  IF LISTCT>0 SET IDX=IDX+1,MENU(IDX)="TEST (and COMPLETE) SELECTED medication entries (RX LIST)"_$CHAR(9)_"SEL_AND_TEST"
  SET IDX=IDX+1,MENU(IDX)="Edit A medication record"_$CHAR(9)_"EDIT^OTHER"
  SET IDX=IDX+1,MENU(IDX)="COMPILE example meds from ALL PATIENTS' meds"_$CHAR(9)_"BIGLIST"
  SET IDX=IDX+1,MENU(IDX)="RESTORE meds previously completed. "_$CHAR(9)_"RESTORE"
  SET IDX=IDX+1,MENU(IDX)="Dump (examine) a medication mapping record"_$CHAR(9)_"DUMP"
  IF LISTCT>0 SET IDX=IDX+1,MENU(IDX)="DEBUG through PICK process"_$CHAR(9)_"DEBUG PICK"
  IF LISTCT>0 SET IDX=IDX+1,MENU(IDX)="DEBUG through TEST process"_$CHAR(9)_"DEBUG TEST"
  IF LISTCT>0 SET IDX=IDX+1,MENU(IDX)="DELETE selected RX LIST items"_$CHAR(9)_"DELETE"
  IF LISTCT>0 SET IDX=IDX+1,MENU(IDX)="Select Rxs to DELETE from LIST"_$CHAR(9)_"SEL_AND_DELETE"
  SET IDX=IDX+1,MENU(IDX)="Add custom line to RX LIST"_$CHAR(9)_"CUSTOMRXLINE"  
  IF LISTCT>0 SET IDX=IDX+1,MENU(IDX)="Manage DRUG CLASSES"_$CHAR(9)_"RXCLASSES"
  SET IDX=IDX+1,MENU(IDX)="Manage patient MEDICATIONS TABLE"_$CHAR(9)_"RXTABLELISTS"  
  SET IDX=IDX+1,MENU(IDX)="Toggle output mode to 'For Patients' "_$SELECT($GET(OPTION("FOR PATIENTS")):"OFF",1:"ON")_$CHAR(9)_"TOGGLEFORPT"
  IF LISTCT>0 SET IDX=IDX+1,MENU(IDX)="Select ONE med for debugging"_$CHAR(9)_"SEL_ONE"  
  IF $DATA(^TMP("PARSELN^TMGRX001",$J))>0 DO
  . NEW TEMPLN SET TEMPLN=$GET(^TMP("PARSELN^TMGRX001",$J)) QUIT:TEMPLN=""
  . SET IDX=IDX+1,MENU(IDX)="DEBUG parsing: "_TEMPLN_$CHAR(9)_"DEBUG PRIOR"
  SET IDX=IDX+1,MENU(IDX)="More options"_$CHAR(9)_"MORE"
  SET USRPICK=$$MENU^TMGUSRI2(.MENU,"^")
  IF USRPICK="^" GOTO CLSDN
  IF USRPICK="TRAIN" DO  GOTO CSL1
  . DO SELRX(.RXLIST,MASTERREF,.OPTION)
  IF USRPICK="TEST" DO  GOTO CSL1
  . DO SELRX2(.RXLIST,MASTERREF,DONEREF,.OPTION)
  IF USRPICK="SEL_AND_TEST" DO  GOTO CSL1
  . DO SELRX1(.RXLIST,MASTERREF,DONEREF,.OPTION)
  IF USRPICK="DELETE" DO  GOTO CSL1
  . DO DELRXLST(.RXLIST,MASTERREF,DELREF)
  IF USRPICK="SEL_AND_DELETE" DO  GOTO CSL1
  . DO DELSELRXS(.RXLIST,MASTERREF,DELREF)
  IF USRPICK="VIEWLIST" DO  GOTO CSL1
  . DO VIEWLST(.RXLIST) ;"VIEW LIST OF MEDICATIONS
  IF USRPICK="CLEAR" DO  GOTO CSL1
  . KILL RXLIST
  . KILL ^TMP("CONSOLE^TMGRX002",$J)
  IF USRPICK="RESTORE" DO  GOTO CSL1
  . USE $P:(NOESCAPE)
  . DO SELRX3(MASTERREF,DONEREF,.OPTION) ; "PICK COMPLETED parses to be put back into pending list.         
  IF USRPICK="GETLIST" DO  GOTO CSL1
  . USE $P:(NOESCAPE)
  . DO GETRXLST(.RXLIST,MASTERREF)  ;"GET RX LIST
  IF USRPICK="GETPTMEDLIST" DO  GOTO CSL1
  . DO GETMTLST(.RXLIST)
  IF $PIECE(USRPICK,"^",1)="EDIT" DO  GOTO CSL1
  . NEW DIC,X,Y SET DIC=22733,DIC(0)="MAEQ"
  . SET Y=$PIECE(USRPICK,"^",2)
  . IF Y="NEW" SET DIC(0)=DIC(0)_"L"  ;"LAYGO
  . IF Y'>0 WRITE ! DO ^DIC QUIT:Y'>0
  . DO EDITRX^TMGRX005(+Y) 
  IF USRPICK="BIGLIST" DO  GOTO CSL1
  . SET %=2 WRITE "Repopulate the big list of examples"
  . DO YN^DICN WRITE !
  . IF %'=1 QUIT
  . NEW REF SET REF=$NAME(^TMG("TMP","EXAMPLE MEDS"))
  . DO BIGLIST(REF)
  . KILL RXLIST MERGE RXLIST=@REF
  . WRITE !
  IF $PIECE(USRPICK,"^",1)="DUMP" DO  GOTO CSL1
  . NEW IENS SET IENS=$PIECE(USRPICK,"^",2) IF IENS'="" SET IENS=IENS_","
  . NEW OPTION SET OPTION("NO LOOP")=1
  . DO ASKDUMP^TMGDEBU3(22733,IENS,.OPTION)
  IF USRPICK="MORE" DO  GOTO CSL1
  . DO CHKREGRX^TMGRX005("")   
  IF USRPICK="DEBUG PICK" DO  GOTO CSL1
  . DO DIRDEBUG^TMGIDE("DO SELRX^TMGRX002(.RXLIST,MASTERREF,.OPTION)")
  IF USRPICK="DEBUG TEST" DO  GOTO CSL1
  . DO DIRDEBUG^TMGIDE("DO SELRX2^TMGRX002(.RXLIST,MASTERREF,DONEREF,.OPTION)")
  IF USRPICK="DEBUG PRIOR" DO  GOTO CSL1
  . NEW TEMPLN SET TEMPLN=$GET(^TMP("PARSELN^TMGRX001",$J))
  . QUIT:TEMPLN=""  
  . NEW ARR NEW CODE SET CODE="DO PARSELN^TMGRX001(.ARR,TEMPLN,1,.OPTION)"
  . DO DIRDEBUG^TMGIDE(CODE)
  . WRITE !,"Output of debug session would be:",!
  . NEW LINE2 SET LINE2=$$EXTERNAL^TMGRX003(.ARR,.OPTION)
  . WRITE LINE2,!
  . DO PRESS2GO^TMGUSRI2
  IF USRPICK="CUSTOMRXLINE" DO  GOTO CSL1
  . WRITE "Enter custom RX line (^ to abort): "
  . NEW LINE READ LINE:3600 WRITE !
  . SET LINE=$$TRIM^XLFSTR(LINE)
  . IF (LINE["^")!(LINE="") QUIT
  . SET RXLIST(LINE)=""
  . DO SAVRXLST(.RXLIST)  ;"SAVE RX LIST
  IF USRPICK="RXCLASSES" DO  GOTO CSL1
  . DO HNDLCLSS^TMGRX006(.RXLIST) ;"HANDLE CLASSES
  IF USRPICK="RXTABLELISTS" DO  GOTO CSL1
  . DO CONSOLE^TMGRX007
  IF USRPICK="TOGGLEFORPT" DO  GOTO CSL1
  . SET OPTION("FOR PATIENTS")='$GET(OPTION("FOR PATIENTS"))
  IF USRPICK="SEL_ONE" DO  GOTO CSL1
  . ;"pick one line from list
  . NEW TMP SET TMP=$$SEL1RXFROMLIST("RXLIST")
  . IF TMP'="" DO
  . . DO PARSELN^TMGRX001(,TMP,0,.OPTION) ;"PARSE ONE MED LINE
  . . WRITE !,"OK, Rx may now be picked for DEBUGGING",!
  . DO PRESS2GO^TMGUSRI2
  GOTO CSL1
  ;
CLSDN  ;
  DO SAVRXLST(.RXLIST)  ;"SAVE RX LIST
  QUIT
  ;
GETREFS(MASTERREF,DONEREF,DELREF,CURREF) ;
  ;"NOTE: as ov 8/25/25, I'm not using DONEREF,DELREF OR CURREF.  Just MASTERREF
  ;"      ... it is possible older code uses these, but I'm not using the older code. 
  SET MASTERREF=$NAME(^TMG("TMP","EXAMPLE MEDS","MASTER"))
  SET DONEREF=$NAME(^TMG("TMP","EXAMPLE MEDS","COMPLETED"))
  SET DELREF=$NAME(^TMG("TMP","EXAMPLE MEDS","DELETED"))
  SET CURREF=$NAME(^TMP("TMP","EXAMPLE MEDS","WORKING"))
  QUIT
  ;
ONEPTLIST(REF) ;"Make a list of meds from just 1 patient.
  NEW RESULT SET RESULT=0
  NEW X,Y,DIC SET DIC=2,DIC(0)="MAEQ"
  DO ^DIC WRITE !
  IF +Y'>0 GOTO OPLDN
  NEW PTLIST SET PTLIST(+Y)=""
  DO GETBLIST(REF,.PTLIST)  
  SET RESULT=1  
OPLDN ;
  QUIT RESULT;
  ;
BIGLIST(REF) ;"Make a big list of meds, based on the med tables from ALL patients
  ;"INPUT: REF -- pass by NAME.  Reference to where med list will be saved.  
  NEW PTLIST,TMGDFN SET TMGDFN=0 
  FOR  SET TMGDFN=$ORDER(^DPT(TMGDFN)) QUIT:TMGDFN'>0  DO
  . IF $$ACTIVEPT^TMGPXR03(TMGDFN,2)=0 QUIT  ;"Ignore inactive patients
  . SET PTLIST(TMGDFN)=""  
  DO GETBLIST(REF,.PTLIST)
  QUIT
  ;
CUSTLIST(REF,SDT,EDT,OPTION)  ;"Make a list of meds, based on the med tables from patients active between SDT and EDT
  ;"INPUT: REF -- pass by NAME.  Reference to where med list will be saved.  
  ;"       SDT -- FMDT format, start date.  Default is 0
  ;"       EDT -- FMDT format, end date, default is 9999999
  ;"       OPTION -- OPTIONAL.  Pass by REFERENCE.
  ;"          OPTION("EXCLUDE INACTIVE")=1  If found then any inactive patient is excluded.
  ;"          OPTION("CHECK APPT")=1   If found, then it will only include patients who had appointments
  SET SDT=+$GET(SDT) IF SDT'>0 SET SDT=0
  SET EDT=+$GET(EDT) IF EDT'>0 SET EDT=9999999
  SET SDT=SDT-0.0000001
  SET EDT=EDT+0.0000001
  NEW APPTARRAY DO PTAPPT^TMGSMS05(SDT,EDT,.APPTARRAY)
  NEW CHKAPPT SET CHKAPPT=(+$GET(OPTION("CHECK APPT"))=1)
  NEW ONLYACTIVE SET ONLYACTIVE=(+$GET(OPTION("EXCLUDE INACTIVE"))=1)   
  NEW PTLIST,TMGDFN SET TMGDFN=0
  ;"Gater list of active patients, between SDT, EDT 
  FOR  SET TMGDFN=$ORDER(^DPT(TMGDFN)) QUIT:TMGDFN'>0  DO
  . IF ONLYACTIVE,$$ACTIVEPT^TMGPXR03(TMGDFN,2)=0 QUIT  ;"Ignore inactive patients
  . NEW PTID SET PTID=$PIECE($GET(^DPT(TMGDFN,0)),"^",1,3)
  . ;"Activity shown by TIU note during date range <-- removing since every HL7 message note, or consult note, etc makes patient show as 'active'  
  . ;"NEW FOLLOWDT SET FOLLOWDT=+$ORDER(^TIU(8925,"ZTMGPTDT",TMGDFN,SDT))
  . ;"IF FOLLOWDT>SDT,FOLLOWDT<EDT SET PTLIST(TMGDFN)="" QUIT  ;"Patient is active, so no need to check for appts
  . ;"Activity shown by Medication table update during date range
  . NEW FOLLOWDT SET FOLLOWDT=+$ORDER(^TMG(22733.2,"TMGPTDT",TMGDFN,SDT))
  . IF FOLLOWDT>SDT,FOLLOWDT<EDT DO
  . . SET PTLIST(TMGDFN)="RX^"_FOLLOWDT_"^"_PTID QUIT  ;"Patient is active, so no need to check for appts  
  . ;"Activity shown by appt during date range.  
  . IF CHKAPPT,$DATA(APPTARRAY(TMGDFN)) SET PTLIST(TMGDFN)=$GET(APPTARRAY(TMGDFN)) QUIT  ;"Patient is active, so no further testst needed
  . ;"more inclusions here if needed later.  
  DO GETBLIST(REF,.PTLIST)
  QUIT
  ;
GETBLIST(REF,PTLIST) ;"Get a big list of meds, based on the med tables from patients in provided list. 
  ;"INPUT: REF -- pass by NAME.  Reference to where med list will be saved.  
  ;"       PTLIST -- pass by REFERENCE. Format  PTLIST(<DFN>)=""  List of patients to process.  
  ;"NOTE:  Prior entries in med list are NOT deleted here, just new entries are added.  
  KILL @REF
  NEW MIN SET MIN=$ORDER(PTLIST(0))
  NEW MAX SET MAX=$ORDER(PTLIST("@"),-1)
  NEW STARTH SET STARTH=$H
  NEW TMGDFN SET TMGDFN=0
  FOR  SET TMGDFN=$ORDER(PTLIST(TMGDFN)) QUIT:TMGDFN'>0  DO
  . IF TMGDFN#10=0 DO PROGBAR^TMGUSRI2(TMGDFN,"Progress",1,MAX,60,STARTH)
  . NEW ARR,RXTMPLST
  . DO MEDARR^TMGTIUOJ(.RXTMPLST,TMGDFN,.ARR)  
  . KILL ARR("KEY-VALUE")
  . NEW IDX SET IDX=0 
  . FOR  SET IDX=$ORDER(ARR(IDX)) QUIT:IDX'>0  DO
  . . NEW SRCLINE SET SRCLINE=$GET(ARR(IDX))
  . . NEW LINE SET LINE=$$TRIM^XLFSTR($$UP^XLFSTR(SRCLINE)) 
  . . IF $EXTRACT(LINE,1)="*" QUIT
  . . IF LINE["[MEDICATION" QUIT
  . . SET @REF@(LINE,TMGDFN)=""
  . . SET @REF@(LINE,"SRC")=SRCLINE
  QUIT
  ;
SRCHBIGLIST(OUT,REF,SRCHLINE)  ;"Return DFN'S contining line
  NEW RESULT SET RESULT=0
  NEW MIN SET MIN=$ORDER(^DPT(0))
  NEW MAX SET MAX=$ORDER(^DPT("@"),-1)
  NEW STARTH SET STARTH=$H
  NEW TMGDFN SET TMGDFN=0
  FOR  SET TMGDFN=$ORDER(^DPT(TMGDFN)) QUIT:TMGDFN'>0  DO
  . IF TMGDFN#10=0 DO PROGBAR^TMGUSRI2(TMGDFN,"Progress",1,MAX,60,STARTH)
  . IF $$ACTIVEPT^TMGPXR03(TMGDFN,2)=0 QUIT  ;"Ignore inactive patients
  . NEW ARR,RXTMPLST
  . DO MEDARR^TMGTIUOJ(.RXTMPLST,TMGDFN,.ARR)  ;"//kt 5/7/18
  . KILL ARR("KEY-VALUE")
  . NEW IDX SET IDX=0 
  . FOR  SET IDX=$ORDER(ARR(IDX)) QUIT:IDX'>0  DO
  . . NEW LINE SET LINE=$$TRIM^XLFSTR($$UP^XLFSTR($GET(ARR(IDX)))) 
  . . IF $EXTRACT(LINE,1)="*" QUIT
  . . IF LINE'=SRCHLINE QUIT
  . . SET RESULT=1
  . . SET OUT(TMGDFN)=""
  QUIT RESULT
  ;
GETRXLST(OUT,REF)  ;"GET RX LIST
  NEW TEMP MERGE TEMP=^TMP("CONSOLE^TMGRX002",$J)
  NEW LISTCT SET LISTCT=$SELECT($DATA(OUT)=0:0,1:$$LISTCT^TMGMISC2("OUT"))
  SET %=1
  IF LISTCT>0 WRITE "Current list has ",LISTCT," entries.  Delete" DO YN^DICN WRITE !
  IF %'=1 QUIT
  KILL ^TMP("CONSOLE^TMGRX002",$J)
  KILL OUT
  NEW SORTARR NEW LINE SET LINE=""
  FOR  SET LINE=$ORDER(@REF@(LINE)) QUIT:LINE=""  DO
  . NEW SHOWLINE SET SHOWLINE=LINE
  . NEW WORD DO PEEKNXWD^TMGRX004(SHOWLINE,.WORD)
  . IF (WORD="OTC")!$$ISPREFIX^TMGRX004(,WORD) DO
  . . DO GETNXWRD^TMGRX004(.SHOWLINE)
  . SET SORTARR(SHOWLINE)=LINE
  NEW SHOWLINE,ARR2,COUNT SET SHOWLINE="",COUNT=0
  FOR  SET SHOWLINE=$ORDER(SORTARR(SHOWLINE)) QUIT:SHOWLINE=""  DO
  . SET COUNT=COUNT+1
  . NEW LINE SET LINE=$GET(SORTARR(SHOWLINE))
  . NEW LINE2 SET LINE2=$$RJ^XLFSTR(COUNT,4,"0")_". "_LINE
  . SET ARR2(LINE2)=LINE  
  NEW TEMPOUT
  DO SELECTOR^TMGUSRI3("ARR2","TEMPOUT","Pick meds. <ESC><ESC> to exit.")
  ;"DO SELECTOR^TMGUSRI3(REF,"OUT","Pick meds. <ESC><ESC> to exit.")
  SET LINE=""
  FOR  SET LINE=$ORDER(TEMPOUT(LINE)) QUIT:LINE=""  DO
  . NEW LINE2 SET LINE2=$GET(TEMPOUT(LINE))
  . SET OUT(LINE2)=""
  DO SAVRXLST(.OUT)  ;"SAVE RX LIST
  QUIT
  ;
SAVRXLST(OUT)  ;"SAVE RX LIST
  KILL ^TMP("CONSOLE^TMGRX002",$J)
  MERGE ^TMP("CONSOLE^TMGRX002",$J)=OUT
  QUIT
  ;
VIEWLST(LIST) ;"VIEW LIST OF MEDICATIONS
  NEW NAME SET NAME=""
  NEW SOMESHOWED SET SOMESHOWED=0
  FOR  SET NAME=$ORDER(LIST(NAME)) QUIT:NAME=""  DO
  . SET SOMESHOWED=1
  . WRITE NAME,!   
  DO PRESS2GO^TMGUSRI2
  QUIT
  ;
SELRX(OUT,REF,OPTION) ;
  IF $DATA(OUT)=0 DO GETRXLST(.OUT,REF)
  NEW ABORT SET ABORT=0
  NEW LINE SET LINE=""
  FOR  SET LINE=$ORDER(OUT(LINE)) QUIT:(LINE="")!ABORT  DO
  . NEW TEMP SET TEMP=$$CHKREGRX^TMGRX005(LINE,.ABORT,2,.OPTION)
  . IF TEMP=-1 SET ABORT=1
  DO PRESS2GO^TMGUSRI2
  QUIT
  ;
SELRX1(LIST,MASTERREF,DONEREF,OPTION)  ;"DELETE ITEMS, SELECTED FROM LIST.  
  NEW TMP
  DO SELFROMRXLIST("LIST",.TMP,"Pick medication(s) for TESTING. <ESC><ESC> to exit.")
  DO SELRX2(.TMP,MASTERREF,DONEREF,.OPTION) ; "CHECK WHICH PARSES ARE GOOD. 
  NEW LINE SET LINE=""
  FOR  SET LINE=$ORDER(@DONEREF@(LINE)) QUIT:(LINE="")  DO
  . KILL LIST(LINE)  ;"Ensure deleted items from selected list are removed from LIST
  QUIT
  ;  
SELRX2(OUT,REF,DONEREF,OPTION) ; "CHECK WHICH PARSES ARE GOOD. 
  IF $DATA(OUT)=0 DO GETRXLST(.OUT,REF)
  NEW ABORT SET ABORT=0
  NEW PICK2
  NEW STARTH SET STARTH=$H
  NEW MAX SET MAX=$$LISTCT^TMGMISC2("OUT")
  NEW IDX SET IDX=1
  NEW LINE SET LINE=""
  FOR  SET LINE=$ORDER(OUT(LINE)) QUIT:(LINE="")!ABORT  DO
  . NEW ARR DO PARSELN^TMGRX001(.ARR,LINE,,.OPTION)
  . NEW LINE2 SET LINE2=$$EXTERNAL^TMGRX003(.ARR,.OPTION)
  . SET PICK2($$RJ^XLFSTR(IDX,4,"0")_"-A "_LINE)=""
  . SET PICK2($$RJ^XLFSTR(IDX,4,"0")_"-B "_LINE2)=LINE
  . SET IDX=IDX+1
  . IF IDX#10=0 DO
  . . DO PROGBAR^TMGUSRI2(IDX,"%",1,MAX,60,STARTH)
  NEW OUT2  
  DO SELECTOR^TMGUSRI3("PICK2","OUT2","Pick ""-B"" lines with good parsing. <ESC><ESC> to exit.")
  NEW SOMESHOWN SET SOMESHOWN=0
  SET IDX="" FOR  SET IDX=$ORDER(OUT2(IDX)) QUIT:IDX=""  DO
  . NEW LINE SET LINE=$GET(OUT2(IDX)) QUIT:LINE=""
  . WRITE "Complete: ",LINE,!
  . SET SOMESHOWN=1
  IF SOMESHOWN=0 DO  GOTO SRX2DN
  . WRITE "No medications selected for making COMPLETION.",!
  WRITE "----------------------------------------------",!
  SET %=2
  WRITE "OK to COMPLETE above, removing them from list of active example meds" DO YN^DICN WRITE !
  IF %=1 DO
  . SET IDX="" FOR  SET IDX=$ORDER(OUT2(IDX)) QUIT:IDX=""  DO
  . . NEW LINE SET LINE=$GET(OUT2(IDX)) QUIT:LINE=""
  . . NEW ARR DO PARSELN^TMGRX001(.ARR,LINE,,.OPTION)
  . . NEW LINE2 SET LINE2=$$EXTERNAL^TMGRX003(.ARR)
  . . SET @DONEREF@(LINE)=LINE2
  . . SET @DONEREF@(LINE,"SHOW")=$GET(ARR("RESULT_BEFORE_PREFACE"))
  . . SET @DONEREF@(LINE,"SHOW","PREFACE")=$GET(ARR("RESULT_BEFORE_PREFACE","PREFACE"))
  . . KILL @REF@(LINE)
  . . KILL OUT(LINE)
  . ;"KILL OUT
SRX2DN ;  
  DO PRESS2GO^TMGUSRI2
  QUIT
  ; 
DELRXLST(LIST,MASTERREF,DELREF)  ;"DELETE ALL LIST ITEMS  
  NEW SOMESHOWN SET SOMESHOWN=0
  NEW LINE SET LINE=""
  FOR  SET LINE=$ORDER(LIST(LINE)) QUIT:LINE=""  DO
  . WRITE "DELETE: ",LINE,!
  . SET SOMESHOWN=1
  IF SOMESHOWN=0 DO  GOTO DELRXDN
  . WRITE "No medications selected for making DELETION.",!
  WRITE "----------------------------------------------",!
  SET %=2
  WRITE "OK to DELETE above, removing them from list of active example meds" DO YN^DICN WRITE !
  IF %'=1 GOTO DELRXDN
  DO DELRXS(.LIST,.LIST,MASTERREF,DELREF)
  KILL ^TMP("CONSOLE^TMGRX002",$J)
DELRXDN ;  
  QUIT
  ;
DELSELRXS(LIST,MASTERREF,DELREF)  ;"DELETE ITEMS, SELECTED FROM LIST.  
  NEW TMP
  DO SELFROMRXLIST("LIST",.TMP,"Pick medication(s) for DELETION from active list. <ESC><ESC> to exit.")
  NEW SOMESHOWN SET SOMESHOWN=0
  NEW LINE SET LINE=""
  FOR  SET LINE=$ORDER(TMP(LINE)) QUIT:LINE=""  DO
  . WRITE "DELETE: ",LINE,!
  . SET SOMESHOWN=1
  IF SOMESHOWN=0 DO  GOTO DELSLRXDN
  . WRITE "No medications selected for making DELETION.",!
  WRITE "----------------------------------------------",!
  SET %=2
  WRITE "OK to DELETE above, removing them from list of active example meds" DO YN^DICN WRITE !
  IF %'=1 GOTO DELSLRXDN
  DO DELRXS(.TMP,.LIST,MASTERREF,DELREF)
  KILL ^TMP("CONSOLE^TMGRX002",$J)
DELSLRXDN ;  
  DO PRESS2GO^TMGUSRI2
  QUIT
  ;
DELRXS(DELLIST,LIST,MASTERREF,DELREF) ;
  NEW SOMESHOWN SET SOMESHOWN=0
  NEW LINE SET LINE=""
  SET LINE="" FOR  SET LINE=$ORDER(DELLIST(LINE)) QUIT:LINE=""  DO
  . SET @DELREF@(LINE)=""
  . KILL LIST(LINE)
  . KILL @MASTERREF@(LINE)
  . KILL DELLIST(LINE)
  QUIT
  ;  
SELRX3(MASTERREF,DONEREF,OPTION) ; "CHECK WHICH 'DONE'/COMPLETED parses need to be put back into pending list.   
  NEW ABORT SET ABORT=0
  NEW PICK
  NEW IDX SET IDX=1
  NEW LINE SET LINE=""
  FOR  SET LINE=$ORDER(@DONEREF@(LINE)) QUIT:(LINE="")!ABORT  DO
  . NEW LINE2 SET LINE2=$GET(@DONEREF@(LINE,"SHOW"))
  . SET PICK($$RJ^XLFSTR(IDX,4,"0")_"-A "_LINE)=LINE
  . SET PICK($$RJ^XLFSTR(IDX,4,"0")_"-B "_LINE2)=LINE
  . SET IDX=IDX+1
  NEW OUT  
  DO SELECTOR^TMGUSRI3("PICK","OUT","Pick '-B' lines with BAD parsing to un-complete them. <ESC><ESC> to exit.")
  NEW SOMESHOWN SET SOMESHOWN=0
  SET IDX="" FOR  SET IDX=$ORDER(OUT(IDX)) QUIT:IDX=""  DO
  . NEW LINE SET LINE=$GET(OUT(IDX)) QUIT:LINE=""
  . WRITE "Restore: ",LINE,!
  . SET SOMESHOWN=1
  IF SOMESHOWN=0 DO  GOTO SRX3DN
  . WRITE "No medications selected for Restoration.",!
  WRITE "----------------------------------------------",!
  SET %=2
  WRITE "OK to RESTORE above meds, putting them back into list of active example meds" DO YN^DICN WRITE !
  IF %=1 DO
  . SET IDX="" FOR  SET IDX=$ORDER(OUT(IDX)) QUIT:IDX=""  DO
  . . NEW LINE SET LINE=$GET(OUT(IDX)) QUIT:LINE=""
  . . KILL @DONEREF@(LINE)
  . . SET @MASTERREF@(LINE)=""
SRX3DN ;  
  DO PRESS2GO^TMGUSRI2
  QUIT
  ;    
GETMTLST(OUT) ;"GET RXLIST FROM PATIENT'S MEDICATION TABLE
  NEW X,Y,DIC SET DIC=2,DIC(0)="MAEQ"
  DO ^DIC WRITE !
  IF +Y'>0 QUIT
  NEW TMGDFN SET TMGDFN=+Y
  NEW ARR,TEMP
  ;"DO MEDLIST^TMGTIUOJ(.TEMP,TMGDFN,.ARR)
  DO MEDARR^TMGTIUOJ(.TEMP,TMGDFN,.ARR)
  KILL OUT
  NEW IDX SET IDX=0
  NEW ARR2,TEMPOUT
  FOR  SET IDX=$ORDER(ARR(IDX)) QUIT:IDX'>0  DO
  . NEW LINE SET LINE=$$TRIM^XLFSTR($GET(ARR(IDX))) 
  . IF LINE["[OLD ENTRY]" QUIT
  . IF LINE["[MEDICATION" QUIT
  . IF $EXTRACT(LINE,1)="*" QUIT
  . SET ARR2(LINE)=LINE
  DO SELECTOR^TMGUSRI3("ARR2","TEMPOUT","Pick meds. <ESC><ESC> to exit.")
  NEW LINE SET LINE=""
  FOR  SET LINE=$ORDER(TEMPOUT(LINE)) QUIT:LINE=""  DO
  . NEW LINE2 SET LINE2=$GET(TEMPOUT(LINE))
  . SET OUT(LINE2)=""
  DO SAVRXLST(.OUT)  ;"SAVE RX LIST
  QUIT
  ;
SELFROMRXLIST(ARRREF,OUT,LABEL)  ;"Select subset of Rx's from @ARRREF
  NEW TMPARR KILL OUT
  SET LABEL=$GET(LABEL,"Pick medication(s). <ESC><ESC> to exit.")
  NEW LINE SET LINE=""
  FOR  SET LINE=$ORDER(@ARRREF@(LINE)) QUIT:LINE=""  SET TMPARR(LINE)=LINE
  NEW TMPOUT
  DO SELECTOR^TMGUSRI3("TMPARR","TMPOUT",LABEL)
  SET LINE="" FOR  SET LINE=$ORDER(TMPOUT(LINE)) QUIT:LINE=""  SET OUT(LINE)=""
  QUIT
  ;
SEL1RXFROMLIST(ARRREF)  ;"Select 1 Rx from @ARRREF
  NEW LABEL SET LABEL="Pick ONE medication. <ESC><ESC> to exit."
  NEW TMP DO SELFROMRXLIST(ARRREF,.TMP,LABEL)
  NEW RESULT SET RESULT=$ORDER(TMP(""))  ;"Use only first entry in list. 
  QUIT RESULT
  ;
T2 ; TEST2
  ;"NEW LINE SET LINE="START 8/11/17 VERAPAMIL HCL 80 MG 1 PO TWICE DAILY (TO REPLACE METOPROLOL)"
  NEW LINE SET LINE="CLONAZEPAM 0.5 MG BID PRN (#30/MONTH)"  
  DO CHKREGRX^TMGRX005(LINE,.ABORT,1)
  QUIT
  ;
  ;"NOTE: GETBLIST is changing params.  So if this function is needed, will need to recode.  
  ;"FIX1  ;
  ;"  NEW MASTERREF,DONEREF DO GETREFS(.MASTERREF,.DONEREF) 
  ;"  NEW TEMP
  ;"  DO GETBLIST("TEMP") ;"Get a big list of meds, based on the med tables from ALL patients
  ;"  NEW LINE SET LINE=""
  ;"  FOR  SET LINE=$ORDER(TEMP(LINE)) QUIT:LINE=""  DO
  ;"  . NEW DATA SET DATA=$DATA(@MASTERREF@(LINE))
  ;"  . WRITE DATA," ",LINE,!
  ;"  . IF $DATA(@MASTERREF@(LINE)) QUIT
  ;"  . SET @DONEREF@(LINE)=""
  ;"  KILL TEMP
  ;"  DO FIX2
  ;"  QUIT
  ;
FIX2  ;
  NEW MASTERREF,DONEREF DO GETREFS(.MASTERREF,.DONEREF) 
  WRITE !,"PARSING MEDICATION LINES",!
  NEW CT SET CT=1
  NEW MAX SET MAX=$$LISTCT^TMGMISC2(DONEREF)
  NEW STARTH SET STARTH=$H
  NEW OPTION
  NEW LINE SET LINE=""
  FOR  SET LINE=$ORDER(@DONEREF@(LINE)) QUIT:LINE=""  DO
  . SET CT=CT+1
  . IF CT#10=0 DO PROGBAR^TMGUSRI2(CT,"",1,MAX,60,STARTH)
  . ;"IF $GET(@DONEREF@(LINE))'="" QUIT
  . NEW ARR DO PARSELN^TMGRX001(.ARR,LINE,,.OPTION)
  . NEW LINE2 SET LINE2=$$EXTERNAL^TMGRX003(.ARR)
  . SET @DONEREF@(LINE)=LINE2
  . MERGE @DONEREF@(LINE,"SHOW")=ARR("RESULT_BEFORE_PREFACE")
  QUIT
  ;
FIX3  ;
  NEW MASTERREF,DONEREF DO GETREFS(.MASTERREF,.DONEREF) 
  NEW LINE,LINE2,SHOW SET LINE=""
  FOR  SET LINE=$ORDER(@DONEREF@(LINE)) QUIT:LINE=""  DO
  . SET LINE2=$GET(@DONEREF@(LINE))
  . SET SHOW=$GET(@DONEREF@(LINE,"SHOW"))
  . IF $EXTRACT(LINE2,1)'="'" QUIT
  . WRITE LINE,!
  . WRITE "--",LINE2,!
  . DO UNDEL(LINE)
  QUIT
  ;
ASKUNDEL ;
  NEW MASTERREF,DONEREF DO GETREFS(.MASTERREF,.DONEREF)
  WRITE "Enter line of Rx to undelete:",!
  NEW LINE READ LINE
  IF $DATA(@DONEREF@(LINE))=0 DO  QUIT
  . WRITE "Unable to find that line in the completed array.",!
  DO UNDEL(LINE)
  QUIT
  ;
UNDEL(LINE) ;
  NEW MASTERREF,DONEREF DO GETREFS(.MASTERREF,.DONEREF)
  SET @MASTERREF@(LINE)=""
  KILL @DONEREF@(LINE);
  QUIT
  ;
GTHTMOUT(OUTREF)  ;"GET HTML FOR AN OUTPUT FILE.  
  NEW MASTERREF,DONEREF DO GETREFS(.MASTERREF,.DONEREF) 
  NEW HTMARR,CONTENTS
  NEW IDX,JDX SET (IDX,JDX)=1
  SET @OUTREF@(IDX)="<HTML><HEAD><TITLE>Medication Parsing</TITLE>",IDX=IDX+1
  SET @OUTREF@(IDX)="<STYLE>",IDX=IDX+1
  SET @OUTREF@(IDX)="table, th, td {",IDX=IDX+1
  SET @OUTREF@(IDX)="border: 1px solid black;",IDX=IDX+1
  SET @OUTREF@(IDX)="border-collapse: collapse;",IDX=IDX+1
  SET @OUTREF@(IDX)="}",IDX=IDX+1  
  SET @OUTREF@(IDX)="tr.d0 td {",IDX=IDX+1
  SET @OUTREF@(IDX)="  background-color: #ffffe6;",IDX=IDX+1
  SET @OUTREF@(IDX)="  color: black;",IDX=IDX+1
  SET @OUTREF@(IDX)="}",IDX=IDX+1
  SET @OUTREF@(IDX)="tr.d1 td {",IDX=IDX+1
  SET @OUTREF@(IDX)="  background-color: #e6f7ff;",IDX=IDX+1
  SET @OUTREF@(IDX)="  color: black;",IDX=IDX+1
  SET @OUTREF@(IDX)="}  ",IDX=IDX+1  
  SET @OUTREF@(IDX)="   ",IDX=IDX+1
  SET @OUTREF@(IDX)="</STYLE>",IDX=IDX+1
  SET @OUTREF@(IDX)="</HEAD><BODY>",IDX=IDX+1
  NEW TEMPARR,LINE,LINE2,SHOW SET LINE=""
  FOR  SET LINE=$ORDER(@DONEREF@(LINE)) QUIT:LINE=""  DO
  . SET SHOW=$GET(@DONEREF@(LINE,"SHOW"))
  . SET LINE2=$GET(@DONEREF@(LINE))
  . NEW PREFACE SET PREFACE=$GET(@DONEREF@(LINE,"SHOW","PREFACE"))
  . IF SHOW="" SET SHOW=LINE2 QUIT:SHOW=""
  . ;"IF SHOW="" WRITE "??",LINE," -- ",LINE2,! QUIT
  . SET TEMPARR(SHOW)=LINE
  . IF PREFACE'="" DO
  . . SET TEMPARR(SHOW,"PREFACE")=PREFACE
  SET SHOW=""
  FOR  SET SHOW=$ORDER(TEMPARR(SHOW)) QUIT:SHOW=""  DO
  . NEW PRE SET PRE=$GET(TEMPARR(SHOW))
  . NEW POST SET POST=$GET(TEMPARR(SHOW,"PREFACE")) SET:POST'="" POST=POST_" "
  . SET POST=POST_SHOW
  . SET CONTENTS(JDX,1)=POST
  . IF $EXTRACT(POST,1)="'" SET CONTENTS(JDX,1,"BGCOLOR")="#FF00FF"
  . SET CONTENTS(JDX,2)=PRE
  . SET CONTENTS(JDX,"ATTRS")="class=""d"_(JDX#2=0)_""""   ;"d0 or d1 match classes in css style
  . SET JDX=JDX+1
  DO HTMTABLE^TMGHTM3(OUTREF,.CONTENTS,.IDX)  
  SET @OUTREF@(IDX)="</BODY></HTML>",IDX=IDX+1
  QUIT        
  ;   
R(RESULT,ARGS) ; GET web page view   ;"Modified from R^TMGRST02
  ;"Entry point for webpage display of Rx's at http://192.168.3.99:9080/dbrx
  ;"Input: RESULT -- PASSED BY REFRENCE. AN OUT PARAMETER.  Format:
  ;"         RESULT("mime")=mime type
  ;"         RESULT(#)=<line of result>
  ;"       ARGS 
  ;"NOTE: uses HTTPREQ in global scope.
  NEW TMGRST2 SET TMGRST2=0
  IF TMGRST2=1 DO
  . KILL ARGS,HTTPREQ
  . MERGE ARGS=^TMG("TMP","R^TMGRX002","ARGS")
  . MERGE HTTPREQ=^TMG("TMP","R^TMGRX002","HTTPREQ")
  ELSE  DO
  . KILL ^TMG("TMP","R^TMGRX002")
  . MERGE ^TMG("TMP","R^TMGRX002","ARGS")=ARGS
  . MERGE ^TMG("TMP","R^TMGRX002","HTTPREQ")=HTTPREQ
  ;
  NEW OUT 
  KILL RESULT SET RESULT=$NAME(^TMP($J)) KILL @RESULT
  DO GTHTMOUT("OUT")  ;"GET HTML FOR AN OUTPUT FILE.  
  SET RESULT("mime")="text/html; charset=utf-8"
  MERGE @RESULT=OUT
  QUIT
  ;
FIX4  ;
  NEW IEN22733 SET IEN22733=0
  FOR  SET IEN22733=$ORDER(^TMG(22733,IEN22733)) QUIT:IEN22733'>0  DO
  . NEW N15 SET N15=$GET(^TMG(22744,IEN22733,1.5))
  . NEW PRMOD SET PRMOD=$PIECE(N15,"^",3)
  . NEW PRTA,PRTB SET (PRTA,PRTB)=""
  . NEW CAPA,CAPB,CAPC,CAPD,CAPE,CAPF SET CAPA="LC",CAPB="FU"
  . IF PRMOD="GE" DO         ;"GENERIC ONLY
  . . SET PRTA="GE",PRTB=""
  . ELSE  IF PRMOD="BR" DO   ;"BRAND ONLY
  . . SET PRTA="GBR",PRTB=""  
  . ELSE  IF PRMOD="BO" DO   ;"BOTH GENERIC AND BRAND
  . . SET PRTA="GE",PRTB="GBR"
  . ELSE  IF PRMOD="GBI" DO  ;"GENERIC & BRAND IF PROVIDED
  . . SET PRTA="GE",PRTB="GBI"
  . ELSE  IF PRMOD="BGI" DO  ;"BRAND & GENERIC IF PROVIDED 
  . . SET PRTA="GBR",PRTB="GE"
  . . SET CAPA="FU",CAPB="LC"
  . ELSE  IF PRMOD="GEA" DO  ;"GENERIC & ABBREVIATION
  . . SET PRTA="GE",PRTB="GAB"
  . . SET CAPA="LC",CAPB="UC"
  . ELSE  DO
  . . SET PRTA="GE",PRTB="PBI"
  . NEW PRTC SET PRTC="GMI" SET CAPC="REG"  ;"MODIFIER
  . NEW PRTD SET PRTD="GF"  SET CAPD="LC"   ;"RX FORM
  . NEW PRTE SET PRTE="RDI" SET CAPE="REG"  ;"STRENGTH STR
  . NEW PRTF SET PRTF="RUI" SET CAPF="LC"   ;"UNITS
  . NEW TMGFDA,TMGMSG
  . SET TMGFDA(22733,IEN22733_",",1.11)=PRTA
  . SET TMGFDA(22733,IEN22733_",",1.12)=PRTB
  . SET TMGFDA(22733,IEN22733_",",1.13)=PRTC
  . SET TMGFDA(22733,IEN22733_",",1.14)=PRTD
  . SET TMGFDA(22733,IEN22733_",",1.15)=PRTE
  . SET TMGFDA(22733,IEN22733_",",1.16)=PRTF
  . SET TMGFDA(22733,IEN22733_",",1.21)=CAPA
  . SET TMGFDA(22733,IEN22733_",",1.22)=CAPB
  . SET TMGFDA(22733,IEN22733_",",1.23)=CAPC
  . SET TMGFDA(22733,IEN22733_",",1.24)=CAPD
  . SET TMGFDA(22733,IEN22733_",",1.25)=CAPE
  . SET TMGFDA(22733,IEN22733_",",1.26)=CAPF
  . DO FILE^DIE("","TMGFDA","TMGMSG")
  . IF $DATA(TMGMSG("DIERR")) DO
  . . WRITE !,$$GETERRST^TMGDEBU2(.TMGMSG),!
  QUIT
  ;
